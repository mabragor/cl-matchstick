;;;; cl-matchstick.lisp

(in-package #:cl-matchstick)

;;; "cl-matchstick" goes here. Hacks and glory await!

(define-condition fail-match (error) ())
(defun fail-match ()
  (error 'fail-match))

(defun codewalk-pattern-at-the-car (pattern)
  (case (car pattern)
    (or `(block outer
	   ,@(mapcar (lambda (x)
		       `(handler-case ,(codewalk-pattern x t)
			  (:no-error () (return-from outer expr)))) ; short-circuit
		     (cdr pattern))
	   (fail-match)))
    (len `(progn (if (not (and (listp expr))
			  (equal ,(second pattern) (length expr)))
		     (fail-match))
		 ,(codewalk-pattern (third pattern) t)
		 expr))
    (not `(handler-case ,(codewalk-pattern (second pattern) t)
	    (fail-match () expr)
	    (:no-error () (fail-match))))
    (t `(progn ,(codewalk-pattern pattern)
	       expr))))

(defun codewalk-list-subpattern (pattern)
  (with-gensyms (g!-res)
    (if (consp pattern)
	(case (car pattern)
	  (collect-until (codewalk-pattern `(not ,(second pattern)) t))
	  (collect-while `(let ((,g!-res nil))
			    (iter (while t)
				  (handler-case (rebind-expr-next)
				    (fail-match () (terminate)))
				  (push (handler-case ,(codewalk-pattern (second pattern) t)
					  (fail-match () (rebind-expr-prev) (terminate)))
					,g!-res))
			    (nreverse ,g!-res)))
	  (maybe `(progn (handler-case (rebind-expr-next)
			   (fail-match () nil))
			 (handler-case ,(codewalk-pattern (second pattern) t)
			   (fail-match () (rebind-expr-prev)))))
	  (cdr `(progn (rebind-expr-cdr)
		       ,(codewalk-pattern (second pattern) t)))
	  (car `(progn (rebind-expr-car)
		       ,(codewalk-pattern (second pattern) t)))
	  (cap `(setf (gethash ',(second pattern) cap)
		      ,(codewalk-list-subpattern (third pattern))))
	  (t `(progn (rebind-expr-next)
		     ,(codewalk-pattern pattern))))
	`(progn (rebind-expr-next)
		,(codewalk-pattern pattern)))))

(defvar *vars*)

(defun codewalk-atomic-pattern (pattern)
  (cond ((keywordp pattern) `(if (not (eq ,pattern expr))
				 (fail-match)))
	((stringp pattern) `(if (or (not (stringp expr))
				    (not (string= ,pattern expr)))
				(fail-match)))
	((symbolp pattern) (when (not (eq '_ pattern))
			     (setf (gethash pattern *vars*) t)
			     `(setf (gethash ',pattern cap) expr)))
	(t (error "Don't know how to codewalk this atomic pattern"))))

(defun codewalk-cons-pattern (pattern)
  (with-gensyms (g!-expr-iter)
    `(progn (when (not (consp expr))
	      (fail-match))
	    (let ((,g!-expr-iter (mk-expr-iter expr)))
	      (macrolet ((rebind-expr-car () `(setf expr (funcall ,',g!-expr-iter :car)))
			 (rebind-expr-cdr () `(setf expr (funcall ,',g!-expr-iter :cdr)))
			 (rebind-expr-next () `(setf expr (funcall ,',g!-expr-iter :next)))
			 (rebind-expr-prev () `(setf expr (funcall ,',g!-expr-iter :prev))))
		,@(mapcar (lambda (x)
			    `(let (expr)
			       ,(codewalk-list-subpattern x)))
			  pattern)
		,@(if (or (atom (car (last pattern)))
			  (not (eq 'cdr (car (car (last pattern))))))
		      `((if (not (end-of-iter-p ,g!-expr-iter))
			    (fail-match)))))
	      expr))))

(defun end-of-iter-p (iter)
  (funcall iter :end-p))

(defun codewalk-pattern (pattern &optional at-the-car)
  (if (atom pattern)
      (codewalk-atomic-pattern pattern)
      (if at-the-car
	  (codewalk-pattern-at-the-car pattern)
	  (codewalk-cons-pattern pattern))))

(defun %codewalk-pattern (pattern)
  (let ((*vars* (make-hash-table :test #'eq)))
    (values (codewalk-pattern pattern t) *vars*)))

(defun mk-expr-iter (thing)
  (let ((inner-thing thing)
	prev-cur-thing
	cur-thing
	(index -1))
    (lambda (cmd)
      ;; (format t "inner : ~a, prev-cur-thing : ~a, cur-thing : ~a, index : ~a~%"
      ;; 	      inner-thing prev-cur-thing cur-thing index)
      (ecase cmd
	(:next (if (equal -1 index)
		   (if (not (consp inner-thing))
		       (fail-match))
		   (if (or (not (consp cur-thing))
			   (not (consp (cdr cur-thing))))
		       (fail-match)))
	       (if (equal -1 index)
		   (setf index 0
			 cur-thing inner-thing)
		   (setf index (1+ index)
			 prev-cur-thing cur-thing
			 cur-thing (cdr cur-thing)))
	       (car cur-thing))
	(:prev (if (equal -1 index)
		   (error "Something went horribly wrong -- requesting prev when index -1"))
	       (if (eq :prev-used prev-cur-thing)
		   (error "Something went horribly wrong -- requesting two prevs in a row"))
	       (setf index (1- index)
		     cur-thing prev-cur-thing
		     prev-cur-thing :prev-used)
	       (car cur-thing))
	(:car (if (equal -1 index)
		  (when (or (not (consp inner-thing))
			    (cdr inner-thing))
		    (fail-match))
		  (when (or (not (consp cur-thing))
			    (cdr cur-thing))
		    (fail-match)))
	      (if (equal -1 index)
		  (setf index 0
			cur-thing (car inner-thing))
		  (setf index (1+ index)
			prev-cur-thing cur-thing
			cur-thing (car cur-thing))))
	(:cdr (if (equal -1 index)
		  (setf index 0
			cur-thing (cdr inner-thing))
		  (setf index (1+ index)
			prev-cur-thing cur-thing
			cur-thing (cdr cur-thing))))
	(:end-p (if (equal -1 index)
		    (not (cdr inner-thing))
		    (not (cdr cur-thing))))))))

		  
(defmacro with-match (pattern thing &body body)
  (once-only (thing)
    (multiple-value-bind (code vars) (%codewalk-pattern pattern)
      `(let ((cap (make-hash-table :test #'eq))
	     (expr ,thing))
	 ,code
	 (symbol-macrolet ,(iter (for (key nil) in-hashtable vars)
				 (collect `(,key (gethash ',key cap))))
	   ,@body)))))
